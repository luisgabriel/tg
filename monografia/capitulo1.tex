\chapter{Introdução}

Escrever programas que tirem bom proveito das arquiteturas \emph{multicore} é um desfio para Engenharia de Software. Programas paralelos executam de maneira não-determinística, por isso são difíceis de testar e \emph{bugs} podem ser quase impossíveis de ser reproduzidos. Aliado a isso, as abstrações baseadas em \emph{locks}, que constituem a tecnologia dominante para programação concorrente, são conceitualmente inapropriadas para lidar com esse paradigma. \cite{jones2007beautiful}

Um dos problemas que torna programação baseada em \emph{locks} impraticável é a impossibilidade de se escrever códigos reusáveis. Por exemplo, considere o cenário em que um desenvolver escreveu uma biblioteca que contém a implementação de uma tabela \emph{hash}. A API dessa tabela fornece métodos para inserção e remoção de elementos que são \emph{thread-safe}. Agora suponha que outro desenvolvedor esteja utilizando essa mesma biblioteca em seu software, onde ele utiliza duas instâncias da tabela, \verb|t1| e \verb|t2|. Na regra de negócio de seu software, o segundo desenvolvedor precisa remover um item A de \verb|t1| e inserí-lo em \verb|t2| sem que o estado intermediário, em que nenhuma das tabelas contém A, esteja visível para outras \emph{threads}. A única forma de atender à esse requisito seria se o primeiro desenvolvedor prevesse esse caso de uso e fornecesse na API da biblioteca métodos que permitissem realizar \emph{lock} e \emph{unlock} da tabela. Além de ser algo improvável de ser previsto, esse tipo de método quebra a abstração de tabela \emph{hash} e induz problemas de sincronização como como \emph{deadlock} e condição de corrida caso o usuário da biblioteca realize operações de \emph{lock} e \emph{unlock} na ordem errada ou simplismente esqueça de realizá-las. Em resumo, operações indiviualmente corretas não podem ser compostas em uma operação maior que também seja correta. \cite{harris2005composable}

Diante desse cenário, muitos vêem a popularização de linguagens funcionais como algo iminente \cite{theeconomist}. Um do fatores que confirma essa tendência é o recente surgimento de novas linguagens funcionais como Clojure, F\# e Scala. Outras linguagens funcionais como Erlang e Haskell, apesar de não terem sido criadas recentemente, também têm ganhando muitos adeptos nos últimos anos \cite{ycombinator}.

O principal motivo por esse interesse em torno das linguagens funcionais são algumas características inerentes ao estilo de programação funcional que são bastante convenientes para o desenvolvimento de sistemas concorrentes como, por exemplo, a ênfase em funções puras e a ausência de estado e dados mutáveis. Além disso, boa parte dessas linguagens tentam de alguma forma tornar programação concorrente algo mais palpável. Um bom exemplo disso é que boa parte delas têm boas implementações de mecanismos alternativos à sincronização baseada em \emph{locks} como o Modelo de Atores \cite{agha1986actors} e Memória Transacional em Software \cite{shavit1995software}.

O foco deste trabalho é no mecanismo de Memória Transacional em Software, especialmente nas implementações presentes nas linguagens Clojure e Haskell. Um dos problemas que esse mecanismo  tenta resolver, que foi descrito anteriormente, é possibilitar ao programador compor operações sobre uma memória compartilhada de forma que elas sejam executadas atomicamente e em isolamento. Com o intuito de entender melhor esse mecanismo na prática, bem como levantar as diferenças entre as implementações de Clojure e Haskell, esse trabalho utilizou um programa não trivial, que já foi utilizado em trabalhos relacionados, como objeto de estudo. Esse prorgama consiste em um motor de busca paralelo que foi implementado tanto em Clojure quanto em Haskell utilizando memória transacional. 

Este trabalho está dividido da seguinte forma: no Capítulo 2 será apresentado o conceito de memória transacional e quais requisitos que devem ser atentidos em uma implementação desse tipo de mecanismo. Nos Capítulos 3 e 4 será feita uma breve apresentação sobre as linguagens Clojure e Haskell, respectivamente, bem como o levantamento de detalhes dos modelos de memória transacional implementados em cada linguagem. O Capítulo 5 focará no detalhamento do problema que foi implementado e nos resultados obtidos na comparação entre as duas implementações. Por fim, o Capítulo 6 contém as considerações finais desse trabalho e algumas melhorias que podem ser exploradas em trabalhos futuros.
\chapter{Conclusão}

Nesse trabalho foi apresentado como funciona e quais os requisitos necessário para implementação de um sistema Memória Transacional em Software, bem como a forma com que esse modelo é aplicado nas linguagens funcionais Clojure e Haskell. Por meio da implementação de um motor de busca paralelo, foi possível entender na prática como fazer uso de memória transacional para resolver um problema não trivial.

De uma forma geral, a utilização de memória transacional se mostrou como uma forma bastante natural de se lidar com memória compartilhada em um sistema concorrente. Agrupar um conjunto de operações para serem executadas de maneira atômica parece ser uma forma mais intuitiva de manter a consistência dos dados se comparado à proteção de accesso por meio da utilização de \emph{locks} e variáveis condicionais.

Também é importante notar que a utilização de linguagens funcionais para fins de implementação de sistemas concorrentes é algo bastante viável. Lidar com dados imutáveis isenta o desenvolvedor de muitas preocupações relacionadas à concorrência. E como foi mostrado no Capítulo 5, é possível organizar o código de maneira modularizada e se obter benefícios equiparáveis aos obtidos quando se desenvolve com linguagens orientadas à objetos em relação à modularidade do código.

As duas linguagens utilizadas nesse estudo, embora bastante distintas entre si, se mostraram muito flexíveis para o tipo de tarefa que foram utilizadas. Haskell tem a vantagem de ter um forte \emph{background} acadêmico que embasa grande parte das decisões de projeto da linguagem e reflete em mecanismos extremamente sofisticados e robustos como é o caso do seu sistema de tipos. Clojure, por sua vez, é uma linguagem que vem ganhando muito adeptos nos últimos anos e tem como principal vantagem a integração com a máquina virtual de Java, fazendo com que seja possível utilizar de uma gama de bibliotecas bastante atestadas de maneira muito simples através de uma integração fluída com a linguagem.

Em trabalhos futuros, o primeiro passo será realizar uma análise aprofundada da implementação do motor de busca em Clojure de forma que seja possível otimizá-lo para ter um desempenho equiparável à implementação feita em Haskell. Em seguida, para que as implementações atendam à todos os requisitos da especificação apresentada na Seção 5.1, os outros tipos de consulta serão implementados. A investigação de outros tipos de estruturas para representação do índice também podem ser explorados com a intenção de melhorar o desempenho das consultas e aumentar a concorrência (menos bloqueios) durante a indexação. Por fim, para fazer um estudo mais completo das implementações de STM de Clojure e Haskell seria interessante a utilização de um problema que envolvesse mais operações compostas e dependentes em sua regra de negócios como objeto de estudo.
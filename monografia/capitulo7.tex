\chapter{Conclusão}

Nesse trabalho foi apresentado como funciona e quais os requisitos necessário para implementação de um sistema Memória Transacional em Software, bem como a forma com que esse modelo é aplicado nas linguagens funcionais Clojure e Haskell. Por meio da implementação de um motor de busca paralelo, foi possível entender na prática como fazer uso de memória transacional para resolver um problema não trivial.

De uma forma geral, a utilização de memória transacional se mostrou como uma forma bastante natural de se lidar com memória compartilhada em um sistema concorrente. Agrupar um conjunto de operações para serem executadas de maneira atômica parece ser uma forma mais intuitiva de manter a consistência dos dados se comparado à proteção de accesso por meio da utilização de \emph{locks} e variáveis condicionais.

Também é importante notar que a utilização de linguagens funcionais para implementar sistemas concorrentes é algo bastante viável. Lidar com dados imutáveis isenta o desenvolvedor de muitas preocupações relacionadas à concorrência. E como foi mostrado no Capítulo 5, é possível organizar o código de maneira modularizada e se obter benefícios equiparáveis aos obtidos em linguagens orientadas à objetos no que se refere à modularidade do código.

As duas linguagens utilizadas nesse estudo, embora bastante distintas entre si, se mostraram muito flexíveis para o tipo de tarefa que foram utilizadas. Haskell tem a vantagem de ter um forte \emph{background} acadêmico que embasa grande parte das decisões de projeto da linguagem e reflete em mecanismos extremamente sofisticados e robustos como é o caso do seu sistema de tipos. Clojure, por sua vez, é uma linguagem que vem ganhando muito adeptos nos últimos anos e tem como principal vantagem a integração com a máquina virtual de Java, fazendo com que seja possível utilizar uma gama de bibliotecas bastante atestadas de maneira muito simples através de uma integração fluída com a linguagem.

Os resultados obtidos nesse trabalho também mostraram que, apesar da utilização de memória transacional e linguagens funcionais facilitar o desenvolvimento de sistemas concorrentes, existe uma complexidade intrínseca à esse tipo de sistema que não pode ser desconsiderada. Ainda é necessário muito estudo nessa área para que seja possível diminuir a complexidade de se projetar e implementar soluções que tirem bom proveito das arquiteturas \emph{multicore}.

Em trabalhos futuros, o primeiro passo será implementar os outros tipos de consultas para que as implementações atendam à todos os requisitos da especificação apresentada na Seção 5.1. Também pode-se investigar outras estruturas para representação do índice com a intenção de melhorar o desempenho das consultas e aumentar a concorrência (menos bloqueios) durante a indexação. Por fim, para fazer um estudo mais abrangente dos sistemas de STM de Clojure e Haskell seria interessante utilizar como objeto de estudo um problema que envolva mais operações compostas em sua regra de negócios.